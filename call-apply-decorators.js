// Декораторы - это функция-обертка, которая принимает другую функцию изменяет её поведение 
// (например, добавляя кеширование, логирование, троттлинг/debounce и т.д.) и возвращает новую функцию с расширенной логикой.

// Преимущества:
// Повторное использование декорирующего кода (например, одно и то же кеширование можно применять ко многим функциям).
// Отделение дополнительной логики (например, кеширования или ограничения частоты вызовов) от основной функциональности.
// Возможность комбинировать декораторы, применяя их к одной функции.

// Прозрачное кеширование 
// - если функция выполняет ресурсоемкие вычисления и всегда взвращает одинаковый результат для одного и того же аргумента, 
// ее можно обернуть в декоратор, которые будет сохранять(кешировать) результаты
function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {
      if (cache.has(x)) {
        return cache.get(x); // считываем из кеша
      }
      let result = func(x);  // вызываем оригинальную функцию
      cache.set(x, result);  // сохраняем результат в кеше
      return result;
    };
  }

//   если результат для аргумента x уже вычислен и сохранен, обёртка возвращает его из кеша. 
// Если же результата нет, вызывается оригинальная функция, результат кешируется и затем возвращается.

// Вызов с использованием call и apply
// Методы call и apply позволяют вызвать функцию с указанным значением this и аргументами. 
// Это особенно важно при использовании декораторов для методов объектов – чтобы не потерять контекст.
function exampleDecorator(func) {
    return function(...args) {
      // Передаем оригинальной функции контекст и аргументы:
      return func.apply(this, args); 
    };
  }

// Методы call и apply позволяют вызывать функции с явно заданным значением this, но различаются способом передачи аргументов:
// call
// При использовании call аргументы передаются через запятую отдельно.
func.call(thisArg, arg1, arg2, arg3, ...);
// Если известно конкретное количество фргументов и их легко перечислить

// apply
// При использовании apply аргументы передаются в виде массива (или объектов, похожих на массив).
func.apply(thisArg, [arg1, arg2, arg3, ...]);
// Если аргументы находятся в массиве или их число заранее неизвестно

// Проблема потери контекста при декодировании
// Когда оборачиваются методы объектов через декораторы, часто происходит потеря контекста, 
// потому что вызов декорированной функции происходит отдельно и не привязан к исходному объекту. 
// Это приводит к тому, что this может оказаться undefined или ссылаться не на тот объект, что нужно.
// Используя bind, можно создать версию функции, которая всегда будет иметь корректное значение this.

// Метод bind – это встроенный метод функций в JavaScript, который создаёт новую функцию с фиксированным значением this. 
// Он помогает сохранить нужный контекст, даже если функция вызывается независимо от объекта, к которому она принадлежит.
// При вызове bind, передается нужное значение для this, и возвращается новая функция. 
// Эта функция при каждом вызове будет использовать переданное значение, независимо от того, как и когда её вызывают.