

/* 
Область видимости - это "зона доступности" переменной.
Где переменная "видна" и может быть использована.
*/

// Блочная область видимости (let/const)
// {
//     let message = "Hello"; // переменная видна только в этом блоке
//     console.log(message); // Hello
// }
// // console.log(message); // ReferenceError: message is not defined

// // Функциональная область видимости
// function testScope() {
//     let localVar = "Я локальная";
//     console.log(localVar); // работает
// }
// console.log(localVar); // ReferenceError

/*
Лексическое окружение - это "память" функции о том, где она была создана.
Функция "помнит" все переменные, которые были доступны в момент её создания.
*/

// let globalVar = "Я глобальная";

// function outerFunction() {
//     let outerVar = "Я внешняя";
    
//     function innerFunction() {
//         let innerVar = "Я внутренняя";
//         // Внутренняя функция видит ВСЕ переменные:
//         console.log(innerVar);  // "Я внутренняя"
//         console.log(outerVar);  // "Я внешняя" 
//         console.log(globalVar); // "Я глобальная"
//     }
    
//     return innerFunction;
// }

/*
Замыкание - это когда внутренняя функция "помнит" переменные 
из внешней функции даже после того, как внешняя функция завершилась.

Это как "рюкзак" с переменными, который функция носит с собой.
*/

// Базовое замыкание
// function createCounter() {
//     let count = 0; // эта переменная "захватывается" в замыкание
    
//     return function() {
//         count++; // внутренняя функция помнит count
//         return count;
//     };
// }

// const counter = createCounter();
// console.log(counter()); // 1
// console.log(counter()); // 2
// console.log(counter()); // 3
// // count остается "живой" благодаря замыканию!

// // Замыкание с параметрами
// function createGreeting(name) {
//     return function(message) {
//         return `${message}, ${name}!`;
//     };
// }

// const greetJohn = createGreeting("John");
// console.log(greetJohn("Hello")); // "Hello, John!"
// console.log(greetJohn("Goodbye")); // "Goodbye, John!"


// Колбэки с сохранением контекста
//function setupEventHandlers() {
//     let clickCount = 0;
    
//     return function() {
//         clickCount++;
//         console.log(`Кликнули ${clickCount} раз`);
//     };
// }

// const handleClick = setupEventHandlers();
// // Можно использовать как обработчик события
// // button.addEventListener('click', handleClick);

// // Проблема с циклами

// // НЕПРАВИЛЬНО:
// function createFunctionsWrong() {
//     let functions = [];
    
//     for (var i = 0; i < 3; i++) {
//         functions.push(function() {
//             console.log(i); // все функции выведут 3!
//         });
//     }
    
//     return functions;
// }

// const wrongFunctions = createFunctionsWrong();
// wrongFunctions[0](); // 3 (ожидали 0)
// wrongFunctions[1](); // 3 (ожидали 1)
// wrongFunctions[2](); // 3 (ожидали 2)

// // ПРАВИЛЬНО - Решение 1: использовать let
// function createFunctionsCorrect1() {
//     let functions = [];
    
//     for (let i = 0; i < 3; i++) { // let создает новую переменную на каждой итерации
//         functions.push(function() {
//             console.log(i);
//         });
//     }
    
//     return functions;
// }

/*

1. Что такое замыкание?
   Ответ: Функция + лексическое окружение, в котором она была создана

2. Когда создается замыкание?
   Ответ: Когда внутренняя функция ссылается на переменные внешней функции

3. Зачем нужны замыкания?
   Ответ: Инкапсуляция, создание приватных переменных, фабрики функций

4. Какие проблемы могут быть с замыканиями?
   Ответ: Утечки памяти, проблемы с циклами и var

5. Как работает сборка мусора с замыканиями?
   Ответ: Переменные остаются в памяти, пока есть ссылки на функции, которые их используют
*/


// Задачи:

// Учитывает ли функция последние изменения?
// Функция sayHi использует имя внешней переменной. Какое значение будет использоваться при выполнении функции?
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

sayHi(); // что будет показано: "John" или "Pete"?

// Будет показано "Hi, Pete" - создается переменная name = "John", далее создается функция sayHi 
// и видит переменную из внешней области видимости, но функция созраняет ссылку на переменную name, а не текущее значение
//далее переменная name изменяется на "Pete", вызывается функция и идет по ссылке к переменной name с текущим значением = "Pete"
// функция обращается к переменной по ссылке, поэтому всегда будет актуальное значение

// Какие переменные доступны?
// Приведенная ниже функция makeWorker создает другую функцию и возвращает ее. Эта новая функция может быть вызвана из другого места.

// Будет ли она иметь доступ к внешним переменным из места своего создания, или из места вызова, или из обоих мест?

function makeWorker() {
    let name = "Pete";
  
    return function() {
      alert(name);
    };
  }
  
  let name = "John";
  
  // создаём функцию
  let work = makeWorker();
  
  // вызываем её
  work(); // что будет показано?

// Будет показано "Pete" - так как функция помнит лексическое окружение места своего создания


// Независимы ли счётчики?
// Здесь мы делаем два счётчика: counter и counter2, используя одну и ту же функцию makeCounter.

// Они независимы? Что покажет второй счётчик? 0,1 или 2,3 или что-то ещё?
function makeCounter() {
    let count = 0;
  
    return function() {
      return count++;
    };
  }
  
  let counter = makeCounter();
  let counter2 = makeCounter();
  
  alert( counter() ); // 0
  alert( counter() ); // 1
  
  alert( counter2() ); // ?
  alert( counter2() ); // ?
// Решение:
//   alert( counter2() ); // 0
//   alert( counter2() ); // 1
// так как счетчики полностью независимы, каждый вызов makeCounter() создает новое лексическое окружение с новой переменной count 
// let counter = makeCounter();
// // Создается ОКРУЖЕНИЕ №1 с count = 0
// // counter "привязывается" к этой count

// // 2️⃣ Второй вызов  
// let counter2 = makeCounter();
// // Создается ОКРУЖЕНИЕ №2 с другой count = 0
// // counter2 "привязывается" к своей count

// Функция-фабрика - функция, которая создает и возвращает новые фугкции или объекты, как в примере makeCounter (новые счетчики)

// Объект счётчика
// Здесь объект счётчика создан с помощью функции-конструктора.

// Будет ли он работать? Что покажет?

function Counter() {
    let count = 0;
  
    this.up = function() {
      return ++count;
    };
    this.down = function() {
      return --count;
    };
  }
  
  let counter = new Counter();
  
  alert( counter.up() ); // ?
  alert( counter.up() ); // ?
  alert( counter.down() ); // ?
  //Решение: код рабочий 
  alert( counter.up() ); // 1 
  alert( counter.up() ); // 2
  alert( counter.down() ); // 1

  //Функция-конструктор - функция, предназначенная для создания и инициализации объектов.
  //  В данном примере функция вызывается с оператором new, что привоит к созданию нового объекта
// Внутри функции-конструктора с помощью this назначаются свойства и методы новому объекту,
//  что позволяет ему быть инициализированным нужным образом.

// Функция внутри if
// Посмотрите на код. Какой будет результат у вызова на последней строке?
// Обратите внимание: результат зависит от режима выполнения кода. Здесь используется строгий режим "use strict".
let phrase = "Hello";

if (true) {
  let user = "John";

  function sayHi() {
    alert(`${phrase}, ${user}`);
  }
}

sayHi();
// Решение: код работать не будет 
// Функция sayHi() объявлена внутри блока if, в строгом режиме функция имеет блочную область видимости то есть только внутри блока if
// она недоступно в глобальной области, поэтому вызов вне блока вызовет ошибку (ReferenceError: sayHi is not defined).

// В нестрогом режиме функция sayHi доступна глобально, и её замыкание сохраняет ссылку на блоковое окружение,
//  где user была равна "John". Ответ: вызов sayHi() - "Hello, John"

// Сумма с помощью замыканий
// Напишите функцию sum, которая работает таким образом: sum(a)(b) = a+b.
// Да, именно таким образом, используя двойные круглые скобки (не опечатка).
// Например: 
// sum(1)(2) = 3
// sum(5)(-1) = 4
function sum (a) {
    return function (b) {
        return a + b
    }
}

console.log(sum(1)(2))
console.log(sum(5)(-1))

// Двлйные скобки используем когда функция возвращает новую функцию, Чтобы вторые скобки заработали, первые – должны вернуть функцию.
// функция может быть вызвана поэтапно, сохраняя значения своих аргументов благодаря замыканию.

// Видна ли переменная?
// Что выведет данный код?
let x = 1;

function func() {
  console.log(x); // ?

  let x = 2;
}

func();
// код отработает с ошибкой ReferenceError, так как переменаая х находится во 'временной мертвой зоне'
// то есть она объявлена, и поднимается, но значение не присвоено

// Фильтрация с помощью функции
// У нас есть встроенный метод arr.filter(f) для массивов. Он фильтрует все элементы с помощью функции f.
//  Если она возвращает true, то элемент добавится в возвращаемый массив.
// Сделайте набор «готовых к употреблению» фильтров:

// inBetween(a, b) – между a и b (включительно).
// inArray([...]) – находится в данном массиве.
// Они должны использоваться таким образом:

// arr.filter(inBetween(3,6)) – выбирает только значения между 3 и 6 (включительно).
// arr.filter(inArray([1,2,3])) – выбирает только элементы, совпадающие с одним из элементов массива
// Например:

function inBetween(a, b) {
    return funcction(x) {
        return x >= a && x <=b;
    }
}
// Функция inBetween(3, 6) возвращает функцию,
//  которая для каждого элемента массива проверяет, удовлетворяет ли он условию 3 <= элемент <= 6.

function inArray(array) {
    return function(x) {
        return array.includes(x)
    }
}
// Функция inArray([1, 2, 10]) возвращает функцию, которая проверяет, содержится ли элемент в массиве [1, 2, 10].
// Если да, то элемент остается.

// /* .. ваш код для inBetween и inArray */
// let arr = [1, 2, 3, 4, 5, 6, 7];
// alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6
// alert( arr.filter(inArray([1, 2, 10])) ); // 1,2

// Сортировать по полю
// У нас есть массив объектов, который нужно отсортировать:
let users = [
    { name: "Иван", age: 20, surname: "Иванов" },
    { name: "Пётр", age: 18, surname: "Петров" },
    { name: "Анна", age: 19, surname: "Каренина" }
  ];
// Обычный способ был бы таким:
// по имени (Анна, Иван, Пётр)
users.sort((a, b) => a.name > b.name ? 1 : -1);

// по возрасту (Пётр, Анна, Иван)
users.sort((a, b) => a.age > b.age ? 1 : -1);

// Можем ли мы сделать его короче, например вот таким?
users.sort(byField('name'));
users.sort(byField('age'));

function byField(field) {
    return function(a, b) {
        return a[field] > b[field] ? 1 : -1
    }
}

// Армия функций
// Следующий код создаёт массив из стрелков (shooters).
// Каждая функция предназначена выводить их порядковые номера. Но что-то пошло не так…
// Почему у всех стрелков одинаковые номера?

// Почините код, чтобы он работал как задумано.
// function makeArmy() {
//     let shooters = [];
  
//     let i = 0;
//     while (i < 10) {
//       let shooter = function() { // функция shooter
//         alert( i ); // должна выводить порядковый номер
//       };
//       shooters.push(shooter); // и добавлять стрелка в массив
//       i++;
//     }
  
//     // ...а в конце вернуть массив из всех стрелков
//     return shooters;
//   }
  
//   let army = makeArmy();
  
//   // все стрелки выводят 10 вместо их порядковых номеров (0, 1, 2, 3...)
//   army[0](); // 10 от стрелка с порядковым номером 0
//   army[1](); // 10 от стрелка с порядковым номером 1
//   army[2](); // 10 ...и т.д.

// проблема данного кода в том, что переменная i объявлена вне цикла и каждая создаваемая функция ссылается на нее
// в конце цикла значение i становится равным 10, поэтому все функции выводят 10
// Правильный код 
function makeArmy() {
    let shooters = []
    for (let i = 0; i < 10; i++) {
        shooters.push(function() {
            alert(i)
        })
    }
    return shooters;
}
//for на каждой итерации создает новое лексическое окружение со своей переменной i
