// Лексическое окружение (Lexical Enviroment) - это внутренний объект, в котором ханятся все переменные, функции, аргументы,
// доступные для текущей области видимости.
// При запуске функции создаётся новое лексическое окружение, куда заносятся все объявления переменных и функций.
// Инициализация:
// До начала выполнения кода функция подготавливает объект LexicalEnvironment,
//  записывая туда имена аргументов и переменных 
// (хотя переменные, объявленные через let/const, остаются неинициализированными до строки с их присвоением).

// Цепочка областей видимости:
// Если в текущем лексическом окружении переменная не найдена, поиск продолжается в внешнем лексическом окружении,
//  вплоть до глобального объекта.

// Цепочка областей видимости:
// Если в текущем лексическом окружении переменная не найдена,
//  поиск продолжается в внешнем лексическом окружении, вплоть до глобального объекта.

// Замыкание (Closure) - это сочетание функции и ее лексического окружения, в котором эта функция была создана
// Благодаря замыканиям, функция сохраняет доступ к переменным из внешних областей видимости даже после завершения работы внешней функции.

// Как работает:
// При создании функции она получает скрытое свойство [[Scope]], ссылающееся на объект лексического окружения, где она была объявлена. 
// Даже если эта функция передается или возвращается, она «запоминает» своё окружение,
//  благодаря чему может использовать внешние переменные в дальнейшем.

function makeCounter() {
    let count = 0; // Локальная переменная, недоступная вне функции
  
    return function() {
      return count++;  // Возвращает текущее значение и увеличивает его
    };
  }
  
  let counter = makeCounter();
  console.log(counter()); // 0
  console.log(counter()); // 1

//   Здесь внутренняя функция сохраняет ссылку на переменную count,
//  благодаря чему даже после завершения выполнения makeCounter доступ к count остаётся.

// Временная мертвая зона (Temporal Dead Zone, TDZ)
// Переменные, объявленные с помощью let/const, поднимаются (hoisting), но остаются неинициализированными до тех пор,
//  пока не выполнится строка с присвоением значения. В этот период они находятся в TDZ, и обращение к ним вызывает ReferenceError.

// Что такое outer у лексического окружения?
// Каждое лексическое окружение может содержать ссылку (часто именуемую как «outer») на своё внешнее (родительское) лексическое окружение. 
// Эта ссылка образует цепочку областей видимости: если переменная не найдена в текущем окружении,
// поиск продолжается во внешнем, и так далее до глобального окружения.

// Что такое environment record?
// Environment record – это внутренняя структура данных, которая фактически хранит ассоциации между именами переменных (и функций)
// и их значениями в конкретном лексическом окружении. 
// В спецификации ECMAScript различают декларативные environment records (для локальных переменных, объявленных через let, const или var) 
// и объектные environment records (например, для глобального окружения, основанного на объекте).

// Что такое Scope. В чем разница между скрытым свойством [[Scope]] и объектом outer у лексического окружения?
// Scope (область видимости) – это совокупность переменных, которые доступны в определённом участке кода.
// [[Scope]] – это скрытое внутреннее свойство функции, которое устанавливается в момент её создания 
// и содержит ссылку на лексическое окружение, в котором функция была объявлена. 
// Оно фиксирует «родное» окружение функции и остаётся неизменным, независимо от места вызова.
// outer – это ссылка в лексическом окружении на его внешнее (родительское) лексическое окружение, 
// которая используется для поиска переменных, если они не найдены в текущем окружении.

// Разница:
// Свойство [[Scope]] присваивается непосредственно функции и сохраняет её исходное лексическое окружение, 
// что позволяет ей работать с переменными, на которые она ссылается, даже если вызвана в другом контексте.
// Объект outer является частью лексического окружения и организует цепочку областей видимости, 
// по которой происходит поиск переменных в случае их отсутствия в текущем окружении.

// Задачи:

// Что выведет say в начале кода?
say('Вася'); // Что выведет? Не будет ли ошибки?

var phrase = 'Привет';

function say(name) {
  alert( name + ", " + phrase );
}
// Выведет "Вася, unefined" - за счет всплытия в начало области видимости 
// но инициализаци переменных - присвоение значений - на той же строке, поэтому перемнная щбъявлена, но ее значение undefined

// В какую переменную будет присвоено значение?
// Каков будет результат выполнения этого кода?
var value = 0;

function f() {
  if (1) {
    value = true;
  } else {
    var value = false;
  }

  alert( value );
}

f();

// Изменится ли внешняя переменная value ?
// Внутри функции создается локальная переменная value, которая перекрывает глобальную.
// Присваивание в блоке if присваивает значение локальной переменной.
// alert(value) выводит true.
// Глобальная переменная value остаётся равной 0.

// P.S. Какими будут ответы, если из строки var value = false убрать var?
// Локальная переменная не создается.
// Присваивание обращается к глобальной переменной value.
// alert(value) по-прежнему выводит true, но теперь глобальная переменная value изменяется с 0 на true.
// наличие объявления var value внутри функции f определяет, что все присваивания в этой функции работают с локальной переменной,
// оставляя глобальную переменную нетронутой.


// var window
// Каков будет результат выполнения этого кода? Почему?
function test() {

    alert( window );
  
    var window = 5;
  
    alert( window );
  }
  
  test();

  // underfined, 5 - внутри функции переменная var window поднимается за счет всплытия с начальным значением underfined 
  // - срабатывает первый alert получаем undefined 
  // - далее присваивается значение 5 и при срабатывании второго alert полцчаем 5

  // Вызов "на месте"
  // Каков будет результат выполнения кода? Почему?
  var a = 5

(function() {
  alert(a)
})()
// Результат будет ошибка так как в конце первой строки пропущено ";" - что привет код к такому виду 
var a = 5(function() {
    alert(a)
  })()
  // Здесь число 5 воспринимается как функция, что приводит к ошибке (TypeError), так как 5 не является функцией.

  // IIFE (Immediately Invoked Function Expression) – это функция, которая определяется и сразу же вызывается. 
  // удобный способ создания локального контекста и изоляции кода, 
  // позволяющий избежать нечаянного взаимодействия с глобальной областью видимости.

  // Перекрытие переменной
  // Если во внутренней функции есть своя переменная с именем currentCount – можно ли в ней получить currentCount из внешней функции?
  function makeCounter() {
    var currentCount = 1;
  
    return function() {
      var currentCount;
      // можно ли здесь вывести currentCount из внешней функции (равный 1)?
    };
  }
  // нельзя - так как происходит перекрытие (shadowing). В функции makeCounter имеется переменная currentCount, равная 1.
  // Однако, когда в возвращаемой внутренней функции объявляется своя переменная currentCount через var, 
  // она создает новую локальную переменную, которая перекрывает внешнюю переменную с таким же именем.
  // Из-за этого внутри внутренней функции любая ссылка на currentCount будет относиться к локальной переменной, 
  // а не к значению currentCount из внешней функции (равному 1)


  // Глобальный счётчик
  // Что выведут эти вызовы, если переменная currentCount находится вне makeCounter?
  var currentCount = 1;

function makeCounter() {
  return function() {
    return currentCount++;
  };
}

var counter = makeCounter();
var counter2 = makeCounter();

alert( counter() ); // ? - 1
alert( counter() ); // ? - 2

alert( counter2() ); // ? - 3
alert( counter2() ); // ? - 4
// все счетчики работают с единой глобальной переменной currentCount, и каждый вызов увеличивает её значение.