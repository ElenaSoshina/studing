// Promise - это объект в JavaScript, который связывает "создающий" код с "потребляющим" кодом.
// создающий код - выполняет операцию, которая занимает время (загрузка данных, таймер)
// потребляющий код - код, который ожидает результат операции
// promise - "мост" между ними

// let promise = new Promise(function(resolve, reject) {
//     // функция-исполнитель (executor)
//     // выполняется автоматически при создании Promise
//   });

//   Executor (исполнитель) запускается сразу при создании
//   Получает два колбэка: resolve и reject
//   Должен вызвать один из них при завершении работы 

// Promise имеет внутрение свойства:
// state(состояние):
    // "pending" — ожидание (начальное состояние)
    // "fulfilled" — выполнено успешно (при вызове resolve)
    // "rejected" — выполнено с ошибкой (при вызове reject)
// result(результат):
    // undefined — изначально
    // value — при вызове resolve(value)
    // error — при вызове reject(error)

// Может быть только один результат - resolve или reject
// Первый вызов учитывается - последующие игнорируются
// State и result - внутренние свойства - недоступные напрямую
// Executor должен вызывать resolve или reject - иначе Promise будет висеть в состоянии "pending"

// Promise имеет методы:
    // then(onFulfilled, onRejected) - для обработки успешного выполнения (resolve)
    // catch(onRejected) - для обработки ошибки (reject)
    // finally(onFinally) - для выполнения после завершения (resolve или reject)


// Основные отличия promise от callback:
// Callback - функция которая передается в другую функцию в качестве аргумента и вызывается позже,
//когда операция завершиться 
/*
┌─────────────────────┬─────────────────────────────┬─────────────────────────────┐
│      АСПЕКТ         │           КОЛБЭКИ           │          ПРОМИСЫ            │
├─────────────────────┼─────────────────────────────┼─────────────────────────────┤
│ ЧИТАЕМОСТЬ КОДА     │ ❌ "Callback Hell"          │ ✅ Линейные цепочки          │
│                     │    Пирамида вложенности     │    .then().then().catch()   │
├─────────────────────┼─────────────────────────────┼─────────────────────────────┤
│ ОБРАБОТКА ОШИБОК    │ ❌ В каждом колбэке         │ ✅ Централизованная          │
│                     │    if(err) в каждом         │    Один .catch() в конце    │
├─────────────────────┼─────────────────────────────┼─────────────────────────────┤
│ КОМПОЗИЦИЯ          │ ❌ Ручная реализация        │ ✅ Встроенные методы         │
│                     │    Счетчики, флаги          │    Promise.all/race         │
├─────────────────────┼─────────────────────────────┼─────────────────────────────┤
│ МНОЖЕСТВЕННЫЕ       │ ❌ Только один обработчик   │ ✅ Множество обработчиков    │
│ ОБРАБОТЧИКИ         │    Жесткая связанность      │    .then() сколько угодно   │
├─────────────────────┼─────────────────────────────┼─────────────────────────────┤
│ ОТЛАДКА             │ ❌ Сложная                  │ ✅ Простая с async/await     │
│                     │    Запутанный stack trace   │    Четкий stack trace       │
└─────────────────────┴─────────────────────────────┴─────────────────────────────┘
*/

// Задачи:
// 1. Можно ли "перевыполнить" промис?
// Что выведет код ниже?

// let promise = new Promise(function(resolve, reject) {
//     resolve(1);
  
//     setTimeout(() => resolve(2), 1000);
//   });
  
//   promise.then(alert);

// Код выведет 1, так как промис может быть выполнен только один раз. Все последующие вызовы – игнорируются.

// 2. Задержка на промисах
// Встроенная функция setTimeout использует колбэк-функции. Создайте альтернативу, использующую промисы.

// Функция delay(ms) должна возвращать промис, который перейдёт в состояние «выполнен» через ms миллисекунд,
// так чтобы мы могли добавить к нему .then:

// function delay(ms) {
//     // ваш код
//     return new Promise(function(resolve, reject) {
//         setTimeout(resolve, ms)
//     })
// }
  
// delay(3000).then(() => console.log('выполнилось через 3 секунды'));

// 3. Анимация круга с помощью промиса
// Перепишите функцию showCircle, написанную в задании Анимация круга с помощью колбэка таким образом,
// чтобы она возвращала промис, вместо того чтобы принимать в аргументы функцию-callback.

function showCircle(cx, cy, radius) {
    const div = document.createElement('div')
    div.className = 'circle'
    div.style.width = 0
    div.style.height = 0
    div.style.left = cx + 'px'
    div.style.top = cy + 'px'
    document.body.append(div)

    return new Promise(resolve => {
        requestAnimationFrame(() => {
            div.style.width = radius * 2 + 'px';
            div.style.height = radius * 2 + 'px';
            div.style.marginLeft = -radius + 'px';
            div.style.marginTop = -radius + 'px';
            // событие transitionend может сработать несколько раз (по одному на каждое свойство: width, height, margin-left, margin-top).
            // Одноразовый слушатель предотвращает многократный resolve промиса.
            div.addEventListener('transitionend', () => resolve(div), {once: true})
        })
    })
}

showCircle(150, 150, 100).then(div => {
    div.classList.add('message-ball');
    div.append("Hello, world!");
  });

